# app/models/user.rb
class User
  include MongoMapper::Document

  one :account
end

# app/models/account.rb
class Account
  include MongoMapper::Document

  belongs_to :user

  def create_something
    do_another_thing
    # ...
  end

  def do_another_thing
    # ...
  end
end

# spec/models/account_spec.rb
require 'spec_helper'

describe Account do
  before(:each) do
    @user = User.create(:email => 'jianlin@domain.com', :password => '111111')
    @account = @user.account
  end

  it "#do_another_thing" do
    @account.stub(:do_another_thing)
    @account.do_another_thing
  end

  it "#create_something" do
    @account.stub(:do_another_thing)
    @account.create_something
  end
end

实际运行时，第一个case能成功stub，而第二个case里，方法do_another_thing仍然会执行，stub失败了。
原因在于mongo_mapper对association的处理：
# lib/mongo_mapper/plugins/associations/proxy.rb
def method_missing(method, *args, &block)
  if load_target
    target.send(method, *args, &block)
  end
end

@user.account实际上是个代理对象，不是真正的Account对象（虽然@user.account.class返回的也是Account）。
proxy_object = class << @account; self; end
p proxy_object
target_object = class << @account.target; self; end
p target_object

所以
@account.stub(:do_another_thing)
是给proxy_object加了个stub。
如果是直接在测试里调用do_another_thing方法，则仍然是走proxy_object.do_another_thing的逻辑，没有问题。

但第二个case是在create_something方法里调用do_another_thing方法的，其执行顺序为：
@account.create_something
@account.method_missing
@account.load_target
@account.target.send(:create_something)
target.do_another_thing
这时self已经变成了target_object，而我们之前stub的是proxy_object，所以stub失败了。

又试了一下belongs_to和EmbeddedDocument的one，也有同样的问题。这不奇怪，因为它们都继承自共同的proxy父类。

解决方法：
应该写成
@account.target.stub(:do_another_thing)
或者
@account = @user.account.target

或者弄个全局的解决方法：
https://github.com/linjian/my_stuff/blob/master/code/one_association_stub.rb

本来到这里应该结束了，后来又去试了一下activerecord，发现也有同样的问题。
has_one和belongs_to都有这样的问题，因为它们都返回一个单独的对象。has_many返回的是一个类似数组的对象，不会有谁去对一个数组stub。

在debug的过程中，还发现了一个有趣的现象，activesupport里提供了一个singleton_class方法，然而我打印@account.singleton_class和@account.target.singleton_class，结果居然是一样的，都是@account.target这个对象的singleton class。
翻了下mongo mapper的源码，发现了原因：
# lib/mongo_mapper/plugins/associations/proxy.rb
instance_methods.each { |m| undef_method m unless m =~ /(^__|^nil\?$|^send$|proxy_|^respond_to_missing\?$|^object_id$)/ }
原来为了method_missing能起作用，proxy把自己的绝大部分方法都undefine了，成了一个Blank State。
这也解释了为什么@account.class == @account.target.class == Account

那rspec mock是怎么拿到proxy对象的singleton class的呢？
# lib/rspec/mocks/method_double.rb
def object_singleton_class
  class << @object; self; end
end
看来还是自己动手丰衣足食靠谱啊。
